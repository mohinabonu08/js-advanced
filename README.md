# js-advanced
DESTRUCTURING,REST & SPREAD                                           Destructuring bu maxsus js IFODA uning yordamida biz obyekt yoki arraydan element yoki xossalarni olib ulerni alohida ozgaruvchi sifatida tyinlashimiz mumkin bunda array un [] bunaqa qavsdan obyekt uchun {} bunaqasini ishlatamiz masalan                                                                          const nums = [10, 15, 20, 25];                                               const [num1, num2] = nums;                                                       bu yerda 2-qatorda biz num1 bn num2 ni nums obyektini ichidagi elementlarga teng bogan yangi ozgaruvchi sifatida elon qilepmiz shuning uchunam yani nums ARRAYINING ichidan oletganimiz uchunam [] bundan foydalandik                Spread - takrorlanadigan arrayga va obyektga oxshash qiymatlarni yoyish uchun ishlatiladigan OPERATOR, yani biz spread spread bn array yoki obyektni yoyganimizda undagi element yoki xossalarimiz alohida bittta bitta bolib qoladi huddi destructuringga oxshab ketadi farqi biz bunda obyekt yoki array elementlarini alohida elementlarga kengaydiramiz destructuringda esa ularni alohida ozgaruvchiga elon qilamiz >>                           Purpose:                                                           Destructuring: Extracts values from arrays or properties from objects into variables.                                                                       Spread Operator: Expands elements of an array or object into individual elements;Usage Context:                                                              Destructuring: Used in variable declarations and assignments.                 Spread Operator: Used in array and object literals, function calls, and more.Syntax:                                                              Destructuring: const [a, b] = array; or const { x, y } = object;            Spread Operator: [...array] or {...object}                                    Rest -miqdori aniq bolmagan elementlarni array korinishida ifodalaydigan OPERATOR yani bizda elementlarimizni rest bn jamlashimiz uchun funksiya boladi va alohida qanaqadur,qanchadur elementlar boladi va osha funksiyani parametri sifatida bizdagi elementlarni chaqirvoramiz                               function sum(...numbers) {                                                     return numbers.reduce((acc, num) => acc + num, 0);}                             console.log(sum(1, 2, 3)); // Output: 6                                    console.log(sum(1, 2, 3, 4, 5)); // Output: 15 reduce esa adashmasam arrayda elementlar 0-index dan boshlangani uchun bulardagi birinchi elementni 0-indaxga tenglash uchun ishltiladi
SHORT-CIRCUT,NULLISH & OPTIONAL CHAINING                                Javascript dasturlash tilida berilgan ifodani chapdan oâ€™ngga qarab ||        (OR) va && (AND) operatorlar yordamida hisoblashga short-circuit       evaluation deyiladi.                                                             Agar kutilgan shart bajarilsa, va berilgan ifodaning qolgan qismi shartga     oâ€™z taâ€™sirini koâ€™rsatmasa, berilgan ifoda short-circuitâ€™ga uchraydi va qiymat  darhol qaytarilinadi.                                                       ðŸ’¡ || operatori birinchi rost (true) boâ€™lgan qiymatni darhol qaytarib   yuboradi. Agar berilgan operandâ€™lardan hech qaysisi rost (true) qiymatga      ega boâ€™lmasa, yolgâ€™on (false) qiymati qaytarilinadi.                        ðŸ’¡ && operatori berilgan ifodada yolgâ€™onga (false) uchrasa darhol false          qaytaradi. Agar berilgan operandâ€™larning barchasi rost (true) boâ€™lsa, oxirgi rost qiymat qaytarilinadi.                                                       Nullish coalescing (ðŸ’¡ ?? ) operatori mantiqiy operator boâ€™lib, berilgan ifodaning chap operandi null yoki undefined boâ€™lgan holatda, oâ€™ng  tarafdagi qiymat qaytirilinadi, aks holda chap operand qiymatni qaytaradi.                                                                Optional chaining (ðŸ’¡ ?. ) operatori berilgan obyektni xossasini olishda yoki funksiyasini chaqirishda ishlatilinadi. Agar obyekt yoki berilgan funksiya undefined yoki null boâ€™ladigan boâ€™lsa, berilgan ifoda short circuitâ€™ga uchraydi va natijaviy qiymat undefined â€™ga teng boâ€™ladi va hech qanday xato yuzaga kelmaydi.
MAPS & SETS                                                                      Map obyekti oâ€™zida key-value (kalit-qiymat) koâ€™rinishidagi juftliklarni   saqlaydi va kalitlarni kiritilgan tartibda saqlab turadi huddi obyektga oxshedi faqat sytaxda farq qiladi . maplarga element key-value qoshish uchun  .set() metodidan foydalanamiz uni ochirish uchun .delete() dan maapdan qandaydur xossa olish uchun .get() dan foydalanamiz.                                             Set obyekti unique (bitta) boâ€™lgan qiymatlarni saqlashda ishlatilinadi. Set obyekti qiymatlar toâ€™plamidan tashkil topgan boâ€™lib, berilgan qiymat toâ€™plamda faqatgina bir martta uchrashi mumkun. setga qiymat qoshish uchun esa .add() dan foydalanamiz,setni uzunligini korish uchun yani nechta qiymatlar borligini korish uchun .size metodidan .has(qiymat nomi) ni yozish orqali ushbu qiymat setda bor yoki yoqligini tekshiramiz.huddi mapdegide .delete() bn qiymatlarni ochiramiz .
JS RUNTIME va ENGINE                                                             Javascript Runtime - maxsus muhit boâ€™lib, Javascript kodni ishga tushirish uchun kerak boâ€™ladigan barcha dasturlar va kutubxonalarni oâ€™z ichiga oladi. Uning asosiy qismi JS Engine boâ€™lib, undan tashqari Event Loop, Timerâ€™lar bilan ishlash, va kod ishga tushayotgan muhit bilan aloqa oâ€™rnatish uchun kerak boâ€™ladigan APIâ€™larni ham taqdim etadi                                            ![alt text](image.png)                                                          JS Engine - kompyuter dasturi boâ€™lib, Javascript tilida yozilgan kodni interpret qilishda yordam beradi. Boshqacha qilib aytganda, JS engine JSâ€™da yozilgan kodni ishga tushiradi Hozirga eng mashhur engineâ€™lardan biri Google Chrome V8 hisoblanadi.                                                                     ![alt text](image-1.png)                                                         1. Parser - HTML hujjatimizdagi barcha script tagâ€™laridagi JS kodlarni ajratib olib,va tokenâ€™larga oâ€™giradi                                                    2. AST - oldingi qadamdan olingan tokenâ€™lar yordamida AST nodeâ€™lari yaratilinadi 3. Interpreter - berilgan ASTâ€™dagi nodeâ€™larni oâ€™qib chiqib, byte kodga oâ€™giradi. Kod satr boâ€™ylab, tepadan pastga qarab ishga tushiriladi                       4. Profiler - kodni optimizatsiyalash uchun kuzatadi                           5. Compiler - interpretatsiya sekin boâ€™lgani uchun, koâ€™p qaytariladigan kodlar kompilyatsiya qilinadi va shu orqali kodni ishga tushirish vaqti qisqaradi      JS Engine asosiy qismlari:                                                     Call Stack - berilgan kod ishga tushiriladigan qism                           Heap - memory pool boâ€™lib, dasturimizga kerak boâ€™ladigan obyektlarni saqlash vazifasini bajaradi
EVENT LOOP                                                                       Javascript barcha amaliyotni bitta threadâ€™da amalga oshiradi, bu degani berilgan vaqtda faqatgina bitta kod ishga tushiriladi. Lekin maxsus data structureâ€™lar yordamida, JSâ€™da multi-threadingâ€™ga oâ€™xshash holatni amalga oshirsa boâ€™ladi.     ![alt text](image-2.png)                                                         Call stack - ishga tushirilishi kerak boâ€™lgan barcha funksiyalarni oâ€™zida saqlab turadi. Funksiya oâ€™z ishini tugatgandan soâ€™ng stackâ€™dan olib tashlanadi.         Event/Callback queue - async koâ€™rinishidagi amaliyotlar, misol uchun Timerâ€™lar, API soâ€™rovlar maxsus APIâ€™lar tomonidan amalga oshiriladi. Async amaliyot tugatilganda, unga bogâ€™langan callback funksiya maxsus event/callback queueâ€™ga joylashtiriladi. Event loop esa, queueâ€™dagi birinchi funksiyani olib, call stackâ€™ga ishga tushirish uchun joâ€™natadi.
HOISTING AND TDZ(temporal dead zone)                                             Hoisting - Javascript dasturlash tilida funksiya yoki oâ€™zgaruvchini eâ€™lon qilishdan oldin ishlatish mumkun. Hoisting sababli Javascriptâ€™dagi funksiya va oâ€™zgaruvchilarimiz berilgan scopeâ€™ning yuqori qismiga olib oâ€™tiladi              Oâ€™zgaruvchini eâ€™lon qilishda ishlatgan kaâ€™lit soâ€™zimizga qarab, hosting turli xil natijaga olib keladi                                                        Function hoisting                                                               Funksiyalar bilan ham hoisting yuz beradi. Uning yordamida funksiyani hali eâ€™lon qilinmasidan oldin ishlatish imkoniyati mavjud.Faqatgina function declaration orqali elon qilingan funksiyalarni chaqirganimizda, ular xatosiz ishga tushadi. Function expressionsâ€™lar esa xato beradi                                         TDZ (Temporal Dead Zone) - oâ€™zgaruvchini scope boshlanishi va eâ€™lon qilingan joyigacha boâ€™lgan hududga aytiladi. Oâ€™zgaruvchini TDZ ichida ishlatish,ReferenceErrorâ€™ga olib keladi
VALUE VA REFERENCE MALUMOT TURLARI                                      Javascript dasturlash tilida 7 xil koâ€™rinishdagi primitive maâ€™lumot turlari mavjud va ular: string , number , bigint , boolean , undefined , symbol va null . Bunday maâ€™lumot turlarini saylaydigan oâ€™zgaruvchilarga qiymat berilganda, oâ€™zgaruvchi qiymatni oâ€™zini saqlaydi                                             Assignment (=) operatori orqali, berilgan primitive data type saqlaydigan oâ€™zgaruvchini, boshqa oâ€™zgaruvchiga tenglaganimizda, oâ€™ng tarafdagi oâ€™zgaruvchining qiymati chap tarafdagi oâ€™zgaruvchiga koâ€™chirilib oâ€™tkazilinadi. Reference data type                                                       Oâ€™zgaruvchiga non-primitive yaâ€™ni reference koâ€™rinishidagi oâ€™zgaruvchi berilganda, u qiymatning referenceâ€™si oâ€™zgaruvchida saqlanadi. Reference bu berilgan obyektning xotiradagi manzilidir                                       
VALUE VA REFERENCE MALUMOT TURLARI                                      Javascript dasturlash tilida 7 xil koâ€™rinishdagi primitive maâ€™lumot turlari mavjud va ular: string , number , bigint , boolean , undefined , symbol va null . Bunday maâ€™lumot turlarini saylaydigan oâ€™zgaruvchilarga qiymat berilganda, oâ€™zgaruvchi qiymatni oâ€™zini saqlaydi                                             Assignment (=) operatori orqali, berilgan primitive data type saqlaydigan oâ€™zgaruvchini, boshqa oâ€™zgaruvchiga tenglaganimizda, oâ€™ng tarafdagi oâ€™zgaruvchining qiymati chap tarafdagi oâ€™zgaruvchiga koâ€™chirilib oâ€™tkazilinadi. Reference data type                                                       Oâ€™zgaruvchiga non-primitive yaâ€™ni reference koâ€™rinishidagi oâ€™zgaruvchi berilganda, u qiymatning referenceâ€™si oâ€™zgaruvchida saqlanadi. Reference bu berilgan obyektning xotiradagi manzilidir. Reference turdagi oâ€™zgaruvchilar ustida == yoki === amali bajarilganda, operator ikkala oâ€™zgaruvchinini oâ€™zida saqlab turayotgan xotira manzilini tekshiradi.Maxsus operatorlardan foydalanish orqali, reference turdagi oâ€™zgaruvchilardan ham nusxa olish imkoniyati mavjud masalan spread ,for loop,json parse kabilar
THIS KEYWORD                                                                     Javascript dasturlash tilida, this kaâ€™lit soâ€™zi method chaqirilgan obyektâ€™ga yoki u belgilangan contextâ€™ga reference hisoblanadi. Contextâ€™ga qarab this kaâ€™lit soâ€™zi oâ€™zidagi referenceâ€™ni oâ€™zgartiradi                                                                     thisni biz quyidagi usullarda ishlatolamiz                                     1. Global context - global contextâ€™da (funksiya yoki metod tashqarisida), this global obyektga reference hisoblanadi console.log(this);                        2. Funksiya ichida - oddiy funksiyalarda ham this global obyektga reference saqlaydi  function myFunction() { console.log(this); }                    myFunction();                                                                    Strict mode holatida esa undefined qiymatiga ega boâ€™ladi 'use strict';          3. Obyektning metodi ichida - funksiya obyektning metodi sifatida chaqirilganda,this metod chaqirilayotgan obyektga reference qiladi                        const person = {                                                              name: 'Ulugbek',                                                          printName: function() {                                                   console.log(this.name);}}                                                       person.printName();                                                             4. call va apply holatida - argument sifatida this berib yuborilishi mumkun function printName() {                                                       console.log(`Hello, ${this.name}!`); }                                           const person1 = { name: 'Ulugbek' };                                        printName.call(person1);                                                         5. Arrow funksiya ichida - arrow funksiya ichida this funksiya eâ€™lon qilingan scopeâ€™ga reference qiladi                                                    const person = { name: 'Ulugbek',                                          printName: function() {                                                          setTimeout(() => {                                                           console.log(`Hello, ${this.name}!`);}, 1000); }}                                                                        person.printName()
HIGHER ORDER FUNCTIONS(HOF)                                                      Funksiya qaytaradigan va/yoki argument sifatida boshqa funksiya qabul qiladigan funksiyalarga HOF deyiladi

                                           


